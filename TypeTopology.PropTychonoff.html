<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>TypeTopology.PropTychonoff</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Background">Martin Escardo 29 April 2014.

A proposition-indexed product of pointed compact sets is itself
compact. But the assumption that a proposition-indexed product of
compact sets is compact gives weak excluded middle (negative
propositions are decidable).

The definition of compactness (or exhaustive searchability) is

    compact∙ A = (p : A → 𝟚) → Σ a₀ ꞉ A , p a₀ ＝ ₁ → (a : A) → p a ＝ ₁

With excluded middle for propositions, the above claim is not
surprising, because

    (𝟘 → Y) = Y^𝟘 ≃ 𝟙 (which is always compact),
    (𝟙 → Y) = Y^𝟙 ≃ Y (which is compact if Y is),

and excluded middle for a proposition X amounts to X=𝟘 or X=𝟙, so
that

    Y^X is compact if Y is compact and X is a proposition.

The point is that

    (1) We can reach this conclusion without excluded middle.

    (2) This also holds for dependent products:

        Π x : X , Y x is compact if X is a proposition and Y x is
        compact for every x : X.

        (This product is also written (x : X) → Y x or Π Y in Agda.)

Our Agda proof below can be written rather concisely by expanding the
definitions. We deliberately don&#39;t do that, so that we have a rigorous
informal proof side-by-side with the formal proof. We proceed in a
series of trivial steps, hopefully in the most natural way (although
we had a convoluted path to this supposedly natural way).

</a><a id="1341" class="Markup">\begin{code}</a>

<a id="1355" class="Symbol">{-#</a> <a id="1359" class="Keyword">OPTIONS</a> <a id="1367" class="Pragma">--without-K</a> <a id="1379" class="Pragma">--exact-split</a> <a id="1393" class="Pragma">--safe</a> <a id="1400" class="Pragma">--auto-inline</a> <a id="1414" class="Symbol">#-}</a>

<a id="1419" class="Keyword">open</a> <a id="1424" class="Keyword">import</a> <a id="1431" href="MLTT.Spartan.html" class="Module">MLTT.Spartan</a>

<a id="1445" class="Keyword">open</a> <a id="1450" class="Keyword">import</a> <a id="1457" href="UF.FunExt.html" class="Module">UF.FunExt</a>

<a id="1468" class="Keyword">module</a> <a id="1475" href="TypeTopology.PropTychonoff.html" class="Module">TypeTopology.PropTychonoff</a> <a id="1502" class="Symbol">(</a><a id="1503" href="TypeTopology.PropTychonoff.html#1503" class="Bound">fe</a> <a id="1506" class="Symbol">:</a> <a id="1508" href="UF.FunExt.html#984" class="Function">FunExt</a><a id="1514" class="Symbol">)</a> <a id="1516" class="Keyword">where</a>

<a id="1523" class="Keyword">open</a> <a id="1528" class="Keyword">import</a> <a id="1535" href="TypeTopology.CompactTypes.html" class="Module">TypeTopology.CompactTypes</a>
<a id="1561" class="Keyword">open</a> <a id="1566" class="Keyword">import</a> <a id="1573" href="MLTT.Two-Properties.html" class="Module">MLTT.Two-Properties</a>
<a id="1593" class="Keyword">open</a> <a id="1598" class="Keyword">import</a> <a id="1605" href="UF.Base.html" class="Module">UF.Base</a>
<a id="1613" class="Keyword">open</a> <a id="1618" class="Keyword">import</a> <a id="1625" href="UF.Subsingletons.html" class="Module">UF.Subsingletons</a>
<a id="1642" class="Keyword">open</a> <a id="1647" class="Keyword">import</a> <a id="1654" href="UF.PropIndexedPiSigma.html" class="Module">UF.PropIndexedPiSigma</a>
<a id="1676" class="Keyword">open</a> <a id="1681" class="Keyword">import</a> <a id="1688" href="UF.Equiv.html" class="Module">UF.Equiv</a>
<a id="1697" class="Keyword">open</a> <a id="1702" class="Keyword">import</a> <a id="1709" href="UF.EquivalenceExamples.html" class="Module">UF.EquivalenceExamples</a>

<a id="1733" class="Markup">\end{code}</a><a id="1743" class="Background">

A crucial lemma is

    prop-indexed-product : is-prop X → (a : X) → Π Y ≅ Y a

This is proved in the module Prop-indexed-product. Although it has a
subtle proof, it should be intuitively clear, as X has at most one
element by hypothesis, and if the element is a:X then the product Π Y
should be isomorphic to its only factor Y a.

With this observation, the following proof should be self-contained,
if we recall again the definition of compact set from the module
CompacTypes:

    compact∙ A = (p : A → 𝟚) → Σ a₀ ꞉ A , p a₀ ＝ ₁ → (a : A) → p a ＝ ₁

Recall also that such an a₀ is called a universal witness for the predicate p.

</a><a id="2377" class="Markup">\begin{code}</a>

<a id="prop-tychonoff"></a><a id="2391" href="TypeTopology.PropTychonoff.html#2391" class="Function">prop-tychonoff</a> <a id="2406" class="Symbol">:</a> <a id="2408" class="Symbol">{</a><a id="2409" href="TypeTopology.PropTychonoff.html#2409" class="Bound">X</a> <a id="2411" class="Symbol">:</a> <a id="2413" href="MLTT.Universes.html#279" class="Generalizable">𝓤</a> <a id="2415" href="MLTT.Universes.html#422" class="Function Operator">̇</a> <a id="2417" class="Symbol">}</a> <a id="2419" class="Symbol">{</a><a id="2420" href="TypeTopology.PropTychonoff.html#2420" class="Bound">Y</a> <a id="2422" class="Symbol">:</a> <a id="2424" href="TypeTopology.PropTychonoff.html#2409" class="Bound">X</a> <a id="2426" class="Symbol">→</a> <a id="2428" href="MLTT.Universes.html#281" class="Generalizable">𝓥</a> <a id="2430" href="MLTT.Universes.html#422" class="Function Operator">̇</a> <a id="2432" class="Symbol">}</a>
               <a id="2449" class="Symbol">→</a> <a id="2451" href="UF.Subsingletons.html#498" class="Function">is-prop</a> <a id="2459" href="TypeTopology.PropTychonoff.html#2409" class="Bound">X</a>
               <a id="2476" class="Symbol">→</a> <a id="2478" class="Symbol">((</a><a id="2480" href="TypeTopology.PropTychonoff.html#2480" class="Bound">x</a> <a id="2482" class="Symbol">:</a> <a id="2484" href="TypeTopology.PropTychonoff.html#2409" class="Bound">X</a><a id="2485" class="Symbol">)</a> <a id="2487" class="Symbol">→</a> <a id="2489" href="TypeTopology.CompactTypes.html#4350" class="Function">compact∙</a> <a id="2498" class="Symbol">(</a><a id="2499" href="TypeTopology.PropTychonoff.html#2420" class="Bound">Y</a> <a id="2501" href="TypeTopology.PropTychonoff.html#2480" class="Bound">x</a><a id="2502" class="Symbol">))</a>
               <a id="2520" class="Symbol">→</a> <a id="2522" href="TypeTopology.CompactTypes.html#4350" class="Function">compact∙</a> <a id="2531" class="Symbol">(</a><a id="2532" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="2534" href="TypeTopology.PropTychonoff.html#2420" class="Bound">Y</a><a id="2535" class="Symbol">)</a>
<a id="2537" href="TypeTopology.PropTychonoff.html#2391" class="Function">prop-tychonoff</a> <a id="2552" class="Symbol">{</a><a id="2553" href="TypeTopology.PropTychonoff.html#2553" class="Bound">𝓤</a><a id="2554" class="Symbol">}</a> <a id="2556" class="Symbol">{</a><a id="2557" href="TypeTopology.PropTychonoff.html#2557" class="Bound">𝓥</a><a id="2558" class="Symbol">}</a> <a id="2560" class="Symbol">{</a><a id="2561" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="2562" class="Symbol">}</a> <a id="2564" class="Symbol">{</a><a id="2565" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="2566" class="Symbol">}</a> <a id="2568" href="TypeTopology.PropTychonoff.html#2568" class="Bound">X-is-prop</a> <a id="2578" href="TypeTopology.PropTychonoff.html#2578" class="Bound">ε</a> <a id="2580" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="2582" class="Symbol">=</a> <a id="2584" href="TypeTopology.PropTychonoff.html#6909" class="Function">γ</a>
 <a id="2587" class="Keyword">where</a>
  <a id="2595" href="TypeTopology.PropTychonoff.html#2595" class="Function">have</a> <a id="2600" class="Symbol">:</a> <a id="2602" class="Symbol">(</a><a id="2603" href="Notation.General.html#2151" class="Function">type-of</a> <a id="2611" href="TypeTopology.PropTychonoff.html#2578" class="Bound">ε</a> <a id="2613" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="2615" class="Symbol">((</a><a id="2617" href="TypeTopology.PropTychonoff.html#2617" class="Bound">x</a> <a id="2619" class="Symbol">:</a> <a id="2621" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="2622" class="Symbol">)</a> <a id="2624" class="Symbol">→</a> <a id="2626" href="TypeTopology.CompactTypes.html#4350" class="Function">compact∙</a><a id="2634" class="Symbol">(</a><a id="2635" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="2637" href="TypeTopology.PropTychonoff.html#2617" class="Bound">x</a><a id="2638" class="Symbol">)))</a>
       <a id="2649" href="MLTT.Sigma.html#586" class="Function Operator">×</a> <a id="2651" class="Symbol">(</a><a id="2652" href="Notation.General.html#2151" class="Function">type-of</a> <a id="2660" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="2662" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="2664" class="Symbol">(</a><a id="2665" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="2667" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="2669" class="Symbol">→</a> <a id="2671" href="MLTT.Two.html#152" class="Datatype">𝟚</a><a id="2672" class="Symbol">))</a>
  <a id="2677" href="TypeTopology.PropTychonoff.html#2595" class="Function">have</a> <a id="2682" class="Symbol">=</a> <a id="2684" href="MLTT.Identity-Type.html#186" class="InductiveConstructor">refl</a> <a id="2689" href="MLTT.Sigma.html#423" class="InductiveConstructor Operator">,</a> <a id="2691" href="MLTT.Identity-Type.html#186" class="InductiveConstructor">refl</a>

  <a id="2699" href="TypeTopology.PropTychonoff.html#2699" class="Function">hip</a> <a id="2703" class="Symbol">:</a> <a id="2705" class="Symbol">(</a><a id="2706" href="TypeTopology.PropTychonoff.html#2706" class="Bound">x</a> <a id="2708" class="Symbol">:</a> <a id="2710" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="2711" class="Symbol">)</a> <a id="2713" class="Symbol">→</a> <a id="2715" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="2717" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="2719" href="UF.Equiv.html#1168" class="Function Operator">≃</a> <a id="2721" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="2723" href="TypeTopology.PropTychonoff.html#2706" class="Bound">x</a>
  <a id="2727" href="TypeTopology.PropTychonoff.html#2699" class="Function">hip</a> <a id="2731" class="Symbol">=</a> <a id="2733" href="UF.PropIndexedPiSigma.html#1186" class="Function">prop-indexed-product</a> <a id="2754" class="Symbol">(</a><a id="2755" href="TypeTopology.PropTychonoff.html#1503" class="Bound">fe</a> <a id="2758" href="TypeTopology.PropTychonoff.html#2553" class="Bound">𝓤</a> <a id="2760" href="TypeTopology.PropTychonoff.html#2557" class="Bound">𝓥</a><a id="2761" class="Symbol">)</a> <a id="2763" href="TypeTopology.PropTychonoff.html#2568" class="Bound">X-is-prop</a>

<a id="2774" class="Markup">\end{code}</a><a id="2784" class="Background">

The essence of the first part of the proof is this:

</a><a id="2839" class="Markup">\begin{code}</a>

  <a id="2855" href="TypeTopology.PropTychonoff.html#2855" class="Function">crude</a> <a id="2861" class="Symbol">:</a> <a id="2863" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a> <a id="2865" class="Symbol">→</a> <a id="2867" href="TypeTopology.CompactTypes.html#4350" class="Function">compact∙</a> <a id="2876" class="Symbol">(</a><a id="2877" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="2879" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="2880" class="Symbol">)</a>
  <a id="2884" href="TypeTopology.PropTychonoff.html#2855" class="Function">crude</a> <a id="2890" href="TypeTopology.PropTychonoff.html#2890" class="Bound">x</a> <a id="2892" class="Symbol">=</a> <a id="2894" href="TypeTopology.CompactTypes.html#16778" class="Function">equiv-compact∙</a> <a id="2909" class="Symbol">(</a><a id="2910" href="UF.Equiv.html#6482" class="Function">≃-sym</a><a id="2915" class="Symbol">(</a><a id="2916" href="TypeTopology.PropTychonoff.html#2699" class="Function">hip</a> <a id="2920" href="TypeTopology.PropTychonoff.html#2890" class="Bound">x</a><a id="2921" class="Symbol">))</a> <a id="2924" class="Symbol">(</a><a id="2925" href="TypeTopology.PropTychonoff.html#2578" class="Bound">ε</a> <a id="2927" href="TypeTopology.PropTychonoff.html#2890" class="Bound">x</a><a id="2928" class="Symbol">)</a>

<a id="2931" class="Markup">\end{code}</a><a id="2941" class="Background">

But this is very crude for our purposes (or so it seems).  So we
instead proceed as follows.

The following is what we get from prop-indexed-product, abstractly:

</a><a id="3106" class="Markup">\begin{code}</a>

  <a id="3122" href="TypeTopology.PropTychonoff.html#3122" class="Function">f</a> <a id="3124" class="Symbol">:</a> <a id="3126" class="Symbol">(</a><a id="3127" href="TypeTopology.PropTychonoff.html#3127" class="Bound">x</a> <a id="3129" class="Symbol">:</a> <a id="3131" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="3132" class="Symbol">)</a> <a id="3134" class="Symbol">→</a> <a id="3136" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="3138" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="3140" class="Symbol">→</a> <a id="3142" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="3144" href="TypeTopology.PropTychonoff.html#3127" class="Bound">x</a>
  <a id="3148" href="TypeTopology.PropTychonoff.html#3122" class="Function">f</a> <a id="3150" href="TypeTopology.PropTychonoff.html#3150" class="Bound">x</a> <a id="3152" class="Symbol">=</a> <a id="3154" href="MLTT.Sigma-Type.html#227" class="Field">pr₁</a> <a id="3158" class="Symbol">(</a><a id="3159" href="TypeTopology.PropTychonoff.html#2699" class="Function">hip</a> <a id="3163" href="TypeTopology.PropTychonoff.html#3150" class="Bound">x</a><a id="3164" class="Symbol">)</a>

  <a id="3169" href="TypeTopology.PropTychonoff.html#3169" class="Function">hrf</a> <a id="3173" class="Symbol">:</a> <a id="3175" class="Symbol">(</a><a id="3176" href="TypeTopology.PropTychonoff.html#3176" class="Bound">x</a> <a id="3178" class="Symbol">:</a> <a id="3180" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="3181" class="Symbol">)</a> <a id="3183" class="Symbol">→</a> <a id="3185" href="MLTT.Sigma.html#451" class="Function">Σ</a> <a id="3187" href="TypeTopology.PropTychonoff.html#3187" class="Bound">r</a> <a id="3189" href="MLTT.Sigma.html#451" class="Function">꞉</a> <a id="3191" class="Symbol">(</a><a id="3192" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="3194" href="TypeTopology.PropTychonoff.html#3176" class="Bound">x</a> <a id="3196" class="Symbol">→</a> <a id="3198" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="3200" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="3201" class="Symbol">)</a><a id="3202" href="MLTT.Sigma.html#451" class="Function">,</a> <a id="3204" href="TypeTopology.PropTychonoff.html#3187" class="Bound">r</a> <a id="3206" href="MLTT.Pi.html#541" class="Function Operator">∘</a> <a id="3208" href="TypeTopology.PropTychonoff.html#3122" class="Function">f</a> <a id="3210" href="TypeTopology.PropTychonoff.html#3176" class="Bound">x</a> <a id="3212" href="MLTT.Id.html#1396" class="Function Operator">∼</a> <a id="3214" href="MLTT.Pi.html#472" class="Function">id</a>
  <a id="3219" href="TypeTopology.PropTychonoff.html#3169" class="Function">hrf</a> <a id="3223" href="TypeTopology.PropTychonoff.html#3223" class="Bound">x</a> <a id="3225" class="Symbol">=</a> <a id="3227" href="MLTT.Sigma-Type.html#238" class="Field">pr₂</a> <a id="3231" class="Symbol">(</a><a id="3232" href="MLTT.Sigma-Type.html#238" class="Field">pr₂</a> <a id="3236" class="Symbol">(</a><a id="3237" href="TypeTopology.PropTychonoff.html#2699" class="Function">hip</a> <a id="3241" href="TypeTopology.PropTychonoff.html#3223" class="Bound">x</a><a id="3242" class="Symbol">))</a>

  <a id="3248" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="3250" class="Symbol">:</a> <a id="3252" class="Symbol">(</a><a id="3253" href="TypeTopology.PropTychonoff.html#3253" class="Bound">x</a> <a id="3255" class="Symbol">:</a> <a id="3257" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="3258" class="Symbol">)</a> <a id="3260" class="Symbol">→</a> <a id="3262" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="3264" href="TypeTopology.PropTychonoff.html#3253" class="Bound">x</a> <a id="3266" class="Symbol">→</a> <a id="3268" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="3270" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a>
  <a id="3274" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="3276" href="TypeTopology.PropTychonoff.html#3276" class="Bound">x</a> <a id="3278" class="Symbol">=</a> <a id="3280" href="MLTT.Sigma-Type.html#227" class="Field">pr₁</a> <a id="3284" class="Symbol">(</a><a id="3285" href="TypeTopology.PropTychonoff.html#3169" class="Function">hrf</a> <a id="3289" href="TypeTopology.PropTychonoff.html#3276" class="Bound">x</a><a id="3290" class="Symbol">)</a>

  <a id="3295" href="TypeTopology.PropTychonoff.html#3295" class="Function">hf</a> <a id="3298" class="Symbol">:</a> <a id="3300" class="Symbol">(</a><a id="3301" href="TypeTopology.PropTychonoff.html#3301" class="Bound">x</a> <a id="3303" class="Symbol">:</a> <a id="3305" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="3306" class="Symbol">)</a> <a id="3308" class="Symbol">(</a><a id="3309" href="TypeTopology.PropTychonoff.html#3309" class="Bound">φ</a> <a id="3311" class="Symbol">:</a> <a id="3313" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="3315" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="3316" class="Symbol">)</a> <a id="3318" class="Symbol">→</a> <a id="3320" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="3322" href="TypeTopology.PropTychonoff.html#3301" class="Bound">x</a> <a id="3324" class="Symbol">(</a><a id="3325" href="TypeTopology.PropTychonoff.html#3122" class="Function">f</a> <a id="3327" href="TypeTopology.PropTychonoff.html#3301" class="Bound">x</a> <a id="3329" href="TypeTopology.PropTychonoff.html#3309" class="Bound">φ</a><a id="3330" class="Symbol">)</a> <a id="3332" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="3334" href="TypeTopology.PropTychonoff.html#3309" class="Bound">φ</a>
  <a id="3338" href="TypeTopology.PropTychonoff.html#3295" class="Function">hf</a> <a id="3341" href="TypeTopology.PropTychonoff.html#3341" class="Bound">x</a> <a id="3343" class="Symbol">=</a> <a id="3345" href="MLTT.Sigma-Type.html#238" class="Field">pr₂</a> <a id="3349" class="Symbol">(</a><a id="3350" href="TypeTopology.PropTychonoff.html#3169" class="Function">hrf</a> <a id="3354" href="TypeTopology.PropTychonoff.html#3341" class="Bound">x</a><a id="3355" class="Symbol">)</a>

<a id="3358" class="Markup">\end{code}</a><a id="3368" class="Background">

We define a predicate q x : Y x → 𝟚, for each x : X, from the
predicate p : Π Y → 𝟚 via (part of) the above isomorphism:

</a><a id="3492" class="Markup">\begin{code}</a>

  <a id="3508" href="TypeTopology.PropTychonoff.html#3508" class="Function">q</a> <a id="3510" class="Symbol">:</a> <a id="3512" class="Symbol">(</a><a id="3513" href="TypeTopology.PropTychonoff.html#3513" class="Bound">x</a> <a id="3515" class="Symbol">:</a> <a id="3517" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="3518" class="Symbol">)</a> <a id="3520" class="Symbol">→</a> <a id="3522" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="3524" href="TypeTopology.PropTychonoff.html#3513" class="Bound">x</a> <a id="3526" class="Symbol">→</a> <a id="3528" href="MLTT.Two.html#152" class="Datatype">𝟚</a>
  <a id="3532" href="TypeTopology.PropTychonoff.html#3508" class="Function">q</a> <a id="3534" href="TypeTopology.PropTychonoff.html#3534" class="Bound">x</a> <a id="3536" href="TypeTopology.PropTychonoff.html#3536" class="Bound">y</a> <a id="3538" class="Symbol">=</a> <a id="3540" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="3542" class="Symbol">(</a><a id="3543" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="3545" href="TypeTopology.PropTychonoff.html#3534" class="Bound">x</a> <a id="3547" href="TypeTopology.PropTychonoff.html#3536" class="Bound">y</a><a id="3548" class="Symbol">)</a>

<a id="3551" class="Markup">\end{code}</a><a id="3561" class="Background">

We argue that the following is a universal witness for the
searchability of the type Π Y wrt the predicate p:

</a><a id="3674" class="Markup">\begin{code}</a>

  <a id="3690" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="3693" class="Symbol">:</a> <a id="3695" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="3697" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a>
  <a id="3701" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="3704" href="TypeTopology.PropTychonoff.html#3704" class="Bound">x</a> <a id="3706" class="Symbol">=</a> <a id="3708" href="MLTT.Sigma-Type.html#227" class="Field">pr₁</a> <a id="3712" class="Symbol">(</a><a id="3713" href="TypeTopology.PropTychonoff.html#2578" class="Bound">ε</a> <a id="3715" href="TypeTopology.PropTychonoff.html#3704" class="Bound">x</a> <a id="3717" class="Symbol">(</a><a id="3718" href="TypeTopology.PropTychonoff.html#3508" class="Function">q</a> <a id="3720" href="TypeTopology.PropTychonoff.html#3704" class="Bound">x</a><a id="3721" class="Symbol">))</a>

<a id="3725" class="Markup">\end{code}</a><a id="3735" class="Background">

By hypothesis, it satisfies:

</a><a id="3767" class="Markup">\begin{code}</a>

  <a id="3783" href="TypeTopology.PropTychonoff.html#3783" class="Function">φ₀-spec</a> <a id="3791" class="Symbol">:</a> <a id="3793" class="Symbol">(</a><a id="3794" href="TypeTopology.PropTychonoff.html#3794" class="Bound">x</a> <a id="3796" class="Symbol">:</a> <a id="3798" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="3799" class="Symbol">)</a> <a id="3801" class="Symbol">→</a> <a id="3803" href="TypeTopology.PropTychonoff.html#3508" class="Function">q</a> <a id="3805" href="TypeTopology.PropTychonoff.html#3794" class="Bound">x</a> <a id="3807" class="Symbol">(</a><a id="3808" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="3811" href="TypeTopology.PropTychonoff.html#3794" class="Bound">x</a><a id="3812" class="Symbol">)</a> <a id="3814" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="3816" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="3818" class="Symbol">→</a> <a id="3820" class="Symbol">(</a><a id="3821" href="TypeTopology.PropTychonoff.html#3821" class="Bound">y</a> <a id="3823" class="Symbol">:</a> <a id="3825" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="3827" href="TypeTopology.PropTychonoff.html#3794" class="Bound">x</a><a id="3828" class="Symbol">)</a> <a id="3830" class="Symbol">→</a> <a id="3832" href="TypeTopology.PropTychonoff.html#3508" class="Function">q</a> <a id="3834" href="TypeTopology.PropTychonoff.html#3794" class="Bound">x</a> <a id="3836" href="TypeTopology.PropTychonoff.html#3821" class="Bound">y</a> <a id="3838" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="3840" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
  <a id="3844" href="TypeTopology.PropTychonoff.html#3783" class="Function">φ₀-spec</a> <a id="3852" href="TypeTopology.PropTychonoff.html#3852" class="Bound">x</a> <a id="3854" class="Symbol">=</a> <a id="3856" href="MLTT.Sigma-Type.html#238" class="Field">pr₂</a> <a id="3860" class="Symbol">(</a><a id="3861" href="TypeTopology.PropTychonoff.html#2578" class="Bound">ε</a> <a id="3863" href="TypeTopology.PropTychonoff.html#3852" class="Bound">x</a> <a id="3865" class="Symbol">(</a><a id="3866" href="TypeTopology.PropTychonoff.html#3508" class="Function">q</a> <a id="3868" href="TypeTopology.PropTychonoff.html#3852" class="Bound">x</a><a id="3869" class="Symbol">))</a>

<a id="3873" class="Markup">\end{code}</a><a id="3883" class="Background">

By expanding the definitions, this amounts to:

</a><a id="3933" class="Markup">\begin{code}</a>

  <a id="3949" href="TypeTopology.PropTychonoff.html#3949" class="Function">φ₀-spec₀</a> <a id="3958" class="Symbol">:</a> <a id="3960" class="Symbol">(</a><a id="3961" href="TypeTopology.PropTychonoff.html#3961" class="Bound">x</a> <a id="3963" class="Symbol">:</a> <a id="3965" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="3966" class="Symbol">)</a> <a id="3968" class="Symbol">→</a> <a id="3970" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="3972" class="Symbol">(</a><a id="3973" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="3975" href="TypeTopology.PropTychonoff.html#3961" class="Bound">x</a> <a id="3977" class="Symbol">(</a><a id="3978" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="3981" href="TypeTopology.PropTychonoff.html#3961" class="Bound">x</a><a id="3982" class="Symbol">))</a> <a id="3985" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="3987" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="3989" class="Symbol">→</a> <a id="3991" class="Symbol">(</a><a id="3992" href="TypeTopology.PropTychonoff.html#3992" class="Bound">y</a> <a id="3994" class="Symbol">:</a> <a id="3996" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="3998" href="TypeTopology.PropTychonoff.html#3961" class="Bound">x</a><a id="3999" class="Symbol">)</a> <a id="4001" class="Symbol">→</a> <a id="4003" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4005" class="Symbol">(</a><a id="4006" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="4008" href="TypeTopology.PropTychonoff.html#3961" class="Bound">x</a> <a id="4010" href="TypeTopology.PropTychonoff.html#3992" class="Bound">y</a><a id="4011" class="Symbol">)</a> <a id="4013" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="4015" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
  <a id="4019" href="TypeTopology.PropTychonoff.html#3949" class="Function">φ₀-spec₀</a> <a id="4028" class="Symbol">=</a> <a id="4030" href="TypeTopology.PropTychonoff.html#3783" class="Function">φ₀-spec</a>

<a id="4039" class="Markup">\end{code}</a><a id="4049" class="Background">

By the definition of f in prop-indexed-product (namely f x φ = φ x):

</a><a id="4121" class="Markup">\begin{code}</a>

  <a id="4137" href="TypeTopology.PropTychonoff.html#4137" class="Function">φ₀-spec₁</a> <a id="4146" class="Symbol">:</a> <a id="4148" class="Symbol">(</a><a id="4149" href="TypeTopology.PropTychonoff.html#4149" class="Bound">x</a> <a id="4151" class="Symbol">:</a> <a id="4153" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="4154" class="Symbol">)</a> <a id="4156" class="Symbol">→</a> <a id="4158" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4160" class="Symbol">(</a><a id="4161" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="4163" href="TypeTopology.PropTychonoff.html#4149" class="Bound">x</a> <a id="4165" class="Symbol">(</a><a id="4166" href="TypeTopology.PropTychonoff.html#3122" class="Function">f</a> <a id="4168" href="TypeTopology.PropTychonoff.html#4149" class="Bound">x</a> <a id="4170" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a><a id="4172" class="Symbol">))</a> <a id="4175" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="4177" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="4179" class="Symbol">→</a> <a id="4181" class="Symbol">(</a><a id="4182" href="TypeTopology.PropTychonoff.html#4182" class="Bound">y</a> <a id="4184" class="Symbol">:</a> <a id="4186" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="4188" href="TypeTopology.PropTychonoff.html#4149" class="Bound">x</a><a id="4189" class="Symbol">)</a> <a id="4191" class="Symbol">→</a> <a id="4193" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4195" class="Symbol">(</a><a id="4196" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="4198" href="TypeTopology.PropTychonoff.html#4149" class="Bound">x</a> <a id="4200" href="TypeTopology.PropTychonoff.html#4182" class="Bound">y</a><a id="4201" class="Symbol">)</a> <a id="4203" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="4205" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
  <a id="4209" href="TypeTopology.PropTychonoff.html#4137" class="Function">φ₀-spec₁</a> <a id="4218" class="Symbol">=</a> <a id="4220" href="TypeTopology.PropTychonoff.html#3949" class="Function">φ₀-spec₀</a>

<a id="4230" class="Markup">\end{code}</a><a id="4240" class="Background">

(So we can&#39;t abstract away the definition/proof of
prop-indexed-product.)

In particular, with y = f x φ, we get:

</a><a id="4357" class="Markup">\begin{code}</a>

  <a id="4373" href="TypeTopology.PropTychonoff.html#4373" class="Function">φ₀-spec₁-particular-case</a> <a id="4398" class="Symbol">:</a> <a id="4400" class="Symbol">(</a><a id="4401" href="TypeTopology.PropTychonoff.html#4401" class="Bound">x</a> <a id="4403" class="Symbol">:</a> <a id="4405" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a><a id="4406" class="Symbol">)</a>
                           <a id="4435" class="Symbol">→</a> <a id="4437" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4439" class="Symbol">(</a><a id="4440" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="4442" href="TypeTopology.PropTychonoff.html#4401" class="Bound">x</a> <a id="4444" class="Symbol">(</a><a id="4445" href="TypeTopology.PropTychonoff.html#3122" class="Function">f</a> <a id="4447" href="TypeTopology.PropTychonoff.html#4401" class="Bound">x</a> <a id="4449" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a><a id="4451" class="Symbol">))</a> <a id="4454" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="4456" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
                           <a id="4485" class="Symbol">→</a> <a id="4487" class="Symbol">(</a><a id="4488" href="TypeTopology.PropTychonoff.html#4488" class="Bound">φ</a> <a id="4490" class="Symbol">:</a> <a id="4492" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="4494" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="4495" class="Symbol">)</a> <a id="4497" class="Symbol">→</a> <a id="4499" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4501" class="Symbol">(</a><a id="4502" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="4504" href="TypeTopology.PropTychonoff.html#4401" class="Bound">x</a> <a id="4506" class="Symbol">(</a><a id="4507" href="TypeTopology.PropTychonoff.html#3122" class="Function">f</a> <a id="4509" href="TypeTopology.PropTychonoff.html#4401" class="Bound">x</a> <a id="4511" href="TypeTopology.PropTychonoff.html#4488" class="Bound">φ</a><a id="4512" class="Symbol">))</a> <a id="4515" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="4517" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
  <a id="4521" href="TypeTopology.PropTychonoff.html#4373" class="Function">φ₀-spec₁-particular-case</a> <a id="4546" href="TypeTopology.PropTychonoff.html#4546" class="Bound">x</a> <a id="4548" href="TypeTopology.PropTychonoff.html#4548" class="Bound">r</a> <a id="4550" href="TypeTopology.PropTychonoff.html#4550" class="Bound">φ</a> <a id="4552" class="Symbol">=</a> <a id="4554" href="TypeTopology.PropTychonoff.html#4137" class="Function">φ₀-spec₁</a> <a id="4563" href="TypeTopology.PropTychonoff.html#4546" class="Bound">x</a> <a id="4565" href="TypeTopology.PropTychonoff.html#4548" class="Bound">r</a> <a id="4567" class="Symbol">(</a><a id="4568" href="TypeTopology.PropTychonoff.html#3122" class="Function">f</a> <a id="4570" href="TypeTopology.PropTychonoff.html#4546" class="Bound">x</a> <a id="4572" href="TypeTopology.PropTychonoff.html#4550" class="Bound">φ</a><a id="4573" class="Symbol">)</a>

<a id="4576" class="Markup">\end{code}</a><a id="4586" class="Background">

Using the fact that g x (f x φ) = φ for any x:X, we get:

</a><a id="4646" class="Markup">\begin{code}</a>

  <a id="4662" href="TypeTopology.PropTychonoff.html#4662" class="Function">φ₀-is-universal-witness-assuming-X</a> <a id="4697" class="Symbol">:</a> <a id="4699" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a> <a id="4701" class="Symbol">→</a> <a id="4703" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4705" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="4708" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="4710" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="4712" class="Symbol">→</a> <a id="4714" class="Symbol">(</a><a id="4715" href="TypeTopology.PropTychonoff.html#4715" class="Bound">φ</a> <a id="4717" class="Symbol">:</a> <a id="4719" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="4721" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="4722" class="Symbol">)</a> <a id="4724" class="Symbol">→</a> <a id="4726" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4728" href="TypeTopology.PropTychonoff.html#4715" class="Bound">φ</a> <a id="4730" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="4732" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
  <a id="4736" href="TypeTopology.PropTychonoff.html#4662" class="Function">φ₀-is-universal-witness-assuming-X</a> <a id="4771" href="TypeTopology.PropTychonoff.html#4771" class="Bound">x</a> <a id="4773" href="TypeTopology.PropTychonoff.html#4773" class="Bound">r</a> <a id="4775" href="TypeTopology.PropTychonoff.html#4775" class="Bound">φ</a> <a id="4777" class="Symbol">=</a>
     <a id="4784" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4786" href="TypeTopology.PropTychonoff.html#4775" class="Bound">φ</a>             <a id="4800" href="MLTT.Id.html#1843" class="Function Operator">＝⟨</a> <a id="4803" href="MLTT.Id.html#1165" class="Function">ap</a> <a id="4806" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4808" class="Symbol">((</a><a id="4810" href="TypeTopology.PropTychonoff.html#3295" class="Function">hf</a> <a id="4813" href="TypeTopology.PropTychonoff.html#4771" class="Bound">x</a> <a id="4815" href="TypeTopology.PropTychonoff.html#4775" class="Bound">φ</a><a id="4816" class="Symbol">)</a><a id="4817" href="MLTT.Id.html#1084" class="Function Operator">⁻¹</a><a id="4819" class="Symbol">)</a> <a id="4821" href="MLTT.Id.html#1843" class="Function Operator">⟩</a>
     <a id="4828" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4830" class="Symbol">(</a><a id="4831" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="4833" href="TypeTopology.PropTychonoff.html#4771" class="Bound">x</a> <a id="4835" class="Symbol">(</a><a id="4836" href="TypeTopology.PropTychonoff.html#3122" class="Function">f</a> <a id="4838" href="TypeTopology.PropTychonoff.html#4771" class="Bound">x</a> <a id="4840" href="TypeTopology.PropTychonoff.html#4775" class="Bound">φ</a><a id="4841" class="Symbol">))</a> <a id="4844" href="MLTT.Id.html#1843" class="Function Operator">＝⟨</a> <a id="4847" href="TypeTopology.PropTychonoff.html#4373" class="Function">φ₀-spec₁-particular-case</a> <a id="4872" href="TypeTopology.PropTychonoff.html#4771" class="Bound">x</a> <a id="4874" href="TypeTopology.PropTychonoff.html#4916" class="Function">s</a> <a id="4876" href="TypeTopology.PropTychonoff.html#4775" class="Bound">φ</a> <a id="4878" href="MLTT.Id.html#1843" class="Function Operator">⟩</a>
     <a id="4885" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>               <a id="4901" href="MLTT.Id.html#1925" class="Function Operator">∎</a>
   <a id="4906" class="Keyword">where</a>
    <a id="4916" href="TypeTopology.PropTychonoff.html#4916" class="Function">s</a> <a id="4918" class="Symbol">=</a> <a id="4920" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4922" class="Symbol">(</a><a id="4923" href="TypeTopology.PropTychonoff.html#3248" class="Function">h</a> <a id="4925" href="TypeTopology.PropTychonoff.html#4771" class="Bound">x</a> <a id="4927" class="Symbol">(</a><a id="4928" href="TypeTopology.PropTychonoff.html#3122" class="Function">f</a> <a id="4930" href="TypeTopology.PropTychonoff.html#4771" class="Bound">x</a> <a id="4932" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a><a id="4934" class="Symbol">))</a> <a id="4937" href="MLTT.Id.html#1843" class="Function Operator">＝⟨</a> <a id="4940" href="MLTT.Id.html#1165" class="Function">ap</a> <a id="4943" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4945" class="Symbol">(</a><a id="4946" href="TypeTopology.PropTychonoff.html#3295" class="Function">hf</a> <a id="4949" href="TypeTopology.PropTychonoff.html#4771" class="Bound">x</a> <a id="4951" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a><a id="4953" class="Symbol">)</a> <a id="4955" href="MLTT.Id.html#1843" class="Function Operator">⟩</a>
        <a id="4965" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="4967" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a>             <a id="4982" href="MLTT.Id.html#1843" class="Function Operator">＝⟨</a> <a id="4985" href="TypeTopology.PropTychonoff.html#4773" class="Bound">r</a> <a id="4987" href="MLTT.Id.html#1843" class="Function Operator">⟩</a>
        <a id="4997" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>                <a id="5014" href="MLTT.Id.html#1925" class="Function Operator">∎</a>

<a id="5017" class="Markup">\end{code}</a><a id="5027" class="Background">

Notice that the point x : X vanishes from the conclusion, and so we
are able to omit it from the hypothesis, which is crucial for what
follows.

We get the same conclusion if X is empty:

</a><a id="5217" class="Markup">\begin{code}</a>

  <a id="5233" href="TypeTopology.PropTychonoff.html#5233" class="Function">φ₀-is-universal-witness-assuming-X→𝟘</a> <a id="5270" class="Symbol">:</a> <a id="5272" class="Symbol">(</a><a id="5273" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a> <a id="5275" class="Symbol">→</a> <a id="5277" href="MLTT.Empty-Type.html#149" class="Datatype">𝟘</a><a id="5278" class="Symbol">)</a> <a id="5280" class="Symbol">→</a> <a id="5282" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="5284" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="5287" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="5289" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="5291" class="Symbol">→</a> <a id="5293" class="Symbol">(</a><a id="5294" href="TypeTopology.PropTychonoff.html#5294" class="Bound">φ</a> <a id="5296" class="Symbol">:</a> <a id="5298" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="5300" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="5301" class="Symbol">)</a> <a id="5303" class="Symbol">→</a> <a id="5305" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="5307" href="TypeTopology.PropTychonoff.html#5294" class="Bound">φ</a> <a id="5309" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="5311" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
  <a id="5315" href="TypeTopology.PropTychonoff.html#5233" class="Function">φ₀-is-universal-witness-assuming-X→𝟘</a> <a id="5352" href="TypeTopology.PropTychonoff.html#5352" class="Bound">u</a> <a id="5354" href="TypeTopology.PropTychonoff.html#5354" class="Bound">r</a> <a id="5356" href="TypeTopology.PropTychonoff.html#5356" class="Bound">φ</a> <a id="5358" class="Symbol">=</a> <a id="5360" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="5362" href="TypeTopology.PropTychonoff.html#5356" class="Bound">φ</a>  <a id="5365" href="MLTT.Id.html#1843" class="Function Operator">＝⟨</a> <a id="5368" href="MLTT.Id.html#1165" class="Function">ap</a> <a id="5371" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="5373" href="TypeTopology.PropTychonoff.html#5508" class="Function">claim</a> <a id="5379" href="MLTT.Id.html#1843" class="Function Operator">⟩</a>
                                               <a id="5428" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="5430" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="5433" href="MLTT.Id.html#1843" class="Function Operator">＝⟨</a> <a id="5436" href="TypeTopology.PropTychonoff.html#5354" class="Bound">r</a> <a id="5438" href="MLTT.Id.html#1843" class="Function Operator">⟩</a>
                                               <a id="5487" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>    <a id="5492" href="MLTT.Id.html#1925" class="Function Operator">∎</a>

   <a id="5498" class="Keyword">where</a>
    <a id="5508" href="TypeTopology.PropTychonoff.html#5508" class="Function">claim</a> <a id="5514" class="Symbol">:</a> <a id="5516" href="TypeTopology.PropTychonoff.html#5356" class="Bound">φ</a> <a id="5518" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="5520" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a>
    <a id="5527" href="TypeTopology.PropTychonoff.html#5508" class="Function">claim</a> <a id="5533" class="Symbol">=</a> <a id="5535" href="UF.FunExt.html#1285" class="Function">dfunext</a> <a id="5543" class="Symbol">(</a><a id="5544" href="TypeTopology.PropTychonoff.html#1503" class="Bound">fe</a> <a id="5547" href="TypeTopology.PropTychonoff.html#2553" class="Bound">𝓤</a> <a id="5549" href="TypeTopology.PropTychonoff.html#2557" class="Bound">𝓥</a><a id="5550" class="Symbol">)</a> <a id="5552" class="Symbol">(λ</a> <a id="5555" href="TypeTopology.PropTychonoff.html#5555" class="Bound">x</a> <a id="5557" class="Symbol">→</a> <a id="5559" href="MLTT.Empty.html#316" class="Function">unique-from-𝟘</a> <a id="5573" class="Symbol">(</a><a id="5574" href="TypeTopology.PropTychonoff.html#5352" class="Bound">u</a> <a id="5576" href="TypeTopology.PropTychonoff.html#5555" class="Bound">x</a><a id="5577" class="Symbol">))</a>
<a id="5580" class="Markup">\end{code}</a><a id="5590" class="Background">

So we would get what we want if we had excluded middle, because X is a
proposition and the above shows that both X and X → 𝟘 give the desired
conclusion that φ₀ is a universal witness. But excluded middle is not
needed.

We shuffle the arguments of φ₀-is-universal-witness-assuming-X:

</a><a id="5878" class="Markup">\begin{code}</a>
  <a id="5893" href="TypeTopology.PropTychonoff.html#5893" class="Function">claim₀</a> <a id="5900" class="Symbol">:</a> <a id="5902" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="5904" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="5907" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="5909" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="5911" class="Symbol">→</a> <a id="5913" class="Symbol">(</a><a id="5914" href="TypeTopology.PropTychonoff.html#5914" class="Bound">φ</a> <a id="5916" class="Symbol">:</a> <a id="5918" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="5920" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="5921" class="Symbol">)</a> <a id="5923" class="Symbol">→</a> <a id="5925" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a> <a id="5927" class="Symbol">→</a> <a id="5929" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="5931" href="TypeTopology.PropTychonoff.html#5914" class="Bound">φ</a> <a id="5933" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="5935" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
  <a id="5939" href="TypeTopology.PropTychonoff.html#5893" class="Function">claim₀</a> <a id="5946" href="TypeTopology.PropTychonoff.html#5946" class="Bound">r</a> <a id="5948" href="TypeTopology.PropTychonoff.html#5948" class="Bound">φ</a> <a id="5950" href="TypeTopology.PropTychonoff.html#5950" class="Bound">x</a> <a id="5952" class="Symbol">=</a> <a id="5954" href="TypeTopology.PropTychonoff.html#4662" class="Function">φ₀-is-universal-witness-assuming-X</a> <a id="5989" href="TypeTopology.PropTychonoff.html#5950" class="Bound">x</a> <a id="5991" href="TypeTopology.PropTychonoff.html#5946" class="Bound">r</a> <a id="5993" href="TypeTopology.PropTychonoff.html#5948" class="Bound">φ</a>

<a id="5996" class="Markup">\end{code}</a><a id="6006" class="Background">

We then take the contrapositive of the conclusion X → p φ ＝ ₁, and
use the fact that if a point of the two-point type 𝟚 is ₀, then it is
not ₁:

</a><a id="6153" class="Markup">\begin{code}</a>

  <a id="6169" href="TypeTopology.PropTychonoff.html#6169" class="Function">Claim₁</a> <a id="6176" class="Symbol">:</a> <a id="6178" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6180" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="6183" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6185" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="6187" class="Symbol">→</a> <a id="6189" class="Symbol">(</a><a id="6190" href="TypeTopology.PropTychonoff.html#6190" class="Bound">φ</a> <a id="6192" class="Symbol">:</a> <a id="6194" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="6196" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="6197" class="Symbol">)</a> <a id="6199" class="Symbol">→</a> <a id="6201" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6203" href="TypeTopology.PropTychonoff.html#6190" class="Bound">φ</a> <a id="6205" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6207" href="MLTT.Two.html#168" class="InductiveConstructor">₀</a> <a id="6209" class="Symbol">→</a> <a id="6211" class="Symbol">(</a><a id="6212" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a> <a id="6214" class="Symbol">→</a> <a id="6216" href="MLTT.Empty-Type.html#149" class="Datatype">𝟘</a><a id="6217" class="Symbol">)</a>
  <a id="6221" href="TypeTopology.PropTychonoff.html#6169" class="Function">Claim₁</a> <a id="6228" href="TypeTopology.PropTychonoff.html#6228" class="Bound">r</a> <a id="6230" href="TypeTopology.PropTychonoff.html#6230" class="Bound">φ</a> <a id="6232" class="Symbol">=</a> <a id="6234" href="MLTT.Negation.html#988" class="Function">contrapositive</a><a id="6248" class="Symbol">(</a><a id="6249" href="TypeTopology.PropTychonoff.html#5893" class="Function">claim₀</a> <a id="6256" href="TypeTopology.PropTychonoff.html#6228" class="Bound">r</a> <a id="6258" href="TypeTopology.PropTychonoff.html#6230" class="Bound">φ</a><a id="6259" class="Symbol">)</a> <a id="6261" href="MLTT.Pi.html#541" class="Function Operator">∘</a> <a id="6263" href="MLTT.Two-Properties.html#2585" class="Function">equal-₀-different-from-₁</a>

<a id="6289" class="Markup">\end{code}</a><a id="6299" class="Background">

This concludes the first part of the argument.

We now shuffle the arguments of φ₀-is-universal-witness-assuming-X→𝟘:

</a><a id="6420" class="Markup">\begin{code}</a>

  <a id="6436" href="TypeTopology.PropTychonoff.html#6436" class="Function">Claim₂</a> <a id="6443" class="Symbol">:</a> <a id="6445" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6447" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="6450" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6452" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="6454" class="Symbol">→</a> <a id="6456" class="Symbol">(</a><a id="6457" href="TypeTopology.PropTychonoff.html#6457" class="Bound">φ</a> <a id="6459" class="Symbol">:</a> <a id="6461" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="6463" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="6464" class="Symbol">)</a> <a id="6466" class="Symbol">→</a> <a id="6468" class="Symbol">(</a><a id="6469" href="TypeTopology.PropTychonoff.html#2561" class="Bound">X</a> <a id="6471" class="Symbol">→</a> <a id="6473" href="MLTT.Empty-Type.html#149" class="Datatype">𝟘</a><a id="6474" class="Symbol">)</a> <a id="6476" class="Symbol">→</a> <a id="6478" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6480" href="TypeTopology.PropTychonoff.html#6457" class="Bound">φ</a> <a id="6482" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6484" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
  <a id="6488" href="TypeTopology.PropTychonoff.html#6436" class="Function">Claim₂</a> <a id="6495" href="TypeTopology.PropTychonoff.html#6495" class="Bound">r</a> <a id="6497" href="TypeTopology.PropTychonoff.html#6497" class="Bound">φ</a> <a id="6499" href="TypeTopology.PropTychonoff.html#6499" class="Bound">u</a> <a id="6501" class="Symbol">=</a> <a id="6503" href="TypeTopology.PropTychonoff.html#5233" class="Function">φ₀-is-universal-witness-assuming-X→𝟘</a> <a id="6540" href="TypeTopology.PropTychonoff.html#6499" class="Bound">u</a> <a id="6542" href="TypeTopology.PropTychonoff.html#6495" class="Bound">r</a> <a id="6544" href="TypeTopology.PropTychonoff.html#6497" class="Bound">φ</a>

<a id="6547" class="Markup">\end{code}</a><a id="6557" class="Background">

Combining the two last claims, we get:

</a><a id="6599" class="Markup">\begin{code}</a>

  <a id="6615" href="TypeTopology.PropTychonoff.html#6615" class="Function">Claim₃</a> <a id="6622" class="Symbol">:</a> <a id="6624" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6626" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="6629" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6631" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="6633" class="Symbol">→</a> <a id="6635" class="Symbol">(</a><a id="6636" href="TypeTopology.PropTychonoff.html#6636" class="Bound">φ</a> <a id="6638" class="Symbol">:</a> <a id="6640" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="6642" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="6643" class="Symbol">)</a> <a id="6645" class="Symbol">→</a> <a id="6647" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6649" href="TypeTopology.PropTychonoff.html#6636" class="Bound">φ</a> <a id="6651" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6653" href="MLTT.Two.html#168" class="InductiveConstructor">₀</a> <a id="6655" class="Symbol">→</a> <a id="6657" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6659" href="TypeTopology.PropTychonoff.html#6636" class="Bound">φ</a> <a id="6661" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6663" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
  <a id="6667" href="TypeTopology.PropTychonoff.html#6615" class="Function">Claim₃</a> <a id="6674" href="TypeTopology.PropTychonoff.html#6674" class="Bound">r</a> <a id="6676" href="TypeTopology.PropTychonoff.html#6676" class="Bound">φ</a> <a id="6678" class="Symbol">=</a> <a id="6680" href="TypeTopology.PropTychonoff.html#6436" class="Function">Claim₂</a> <a id="6687" href="TypeTopology.PropTychonoff.html#6674" class="Bound">r</a> <a id="6689" href="TypeTopology.PropTychonoff.html#6676" class="Bound">φ</a> <a id="6691" href="MLTT.Pi.html#541" class="Function Operator">∘</a> <a id="6693" href="TypeTopology.PropTychonoff.html#6169" class="Function">Claim₁</a> <a id="6700" href="TypeTopology.PropTychonoff.html#6674" class="Bound">r</a> <a id="6702" href="TypeTopology.PropTychonoff.html#6676" class="Bound">φ</a>

<a id="6705" class="Markup">\end{code}</a><a id="6715" class="Background">

Finally, we do case analysis on the value of p φ:

</a><a id="6768" class="Markup">\begin{code}</a>

  <a id="6784" href="TypeTopology.PropTychonoff.html#6784" class="Function">φ₀-is-universal-witness</a> <a id="6808" class="Symbol">:</a> <a id="6810" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6812" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="6815" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6817" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="6819" class="Symbol">→</a> <a id="6821" class="Symbol">(</a><a id="6822" href="TypeTopology.PropTychonoff.html#6822" class="Bound">φ</a> <a id="6824" class="Symbol">:</a> <a id="6826" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="6828" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="6829" class="Symbol">)</a> <a id="6831" class="Symbol">→</a> <a id="6833" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6835" href="TypeTopology.PropTychonoff.html#6822" class="Bound">φ</a> <a id="6837" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6839" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a>
  <a id="6843" href="TypeTopology.PropTychonoff.html#6784" class="Function">φ₀-is-universal-witness</a> <a id="6867" href="TypeTopology.PropTychonoff.html#6867" class="Bound">r</a> <a id="6869" href="TypeTopology.PropTychonoff.html#6869" class="Bound">φ</a> <a id="6871" class="Symbol">=</a> <a id="6873" href="MLTT.Two-Properties.html#451" class="Function">𝟚-equality-cases</a> <a id="6890" class="Symbol">(</a><a id="6891" href="TypeTopology.PropTychonoff.html#6615" class="Function">Claim₃</a> <a id="6898" href="TypeTopology.PropTychonoff.html#6867" class="Bound">r</a> <a id="6900" href="TypeTopology.PropTychonoff.html#6869" class="Bound">φ</a><a id="6901" class="Symbol">)</a> <a id="6903" href="MLTT.Pi.html#472" class="Function">id</a>

  <a id="6909" href="TypeTopology.PropTychonoff.html#6909" class="Function">γ</a> <a id="6911" class="Symbol">:</a> <a id="6913" href="MLTT.Sigma.html#451" class="Function">Σ</a> <a id="6915" href="TypeTopology.PropTychonoff.html#6915" class="Bound">φ₀</a> <a id="6918" href="MLTT.Sigma.html#451" class="Function">꞉</a> <a id="6920" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="6922" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a> <a id="6924" href="MLTT.Sigma.html#451" class="Function">,</a> <a id="6926" class="Symbol">(</a><a id="6927" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6929" href="TypeTopology.PropTychonoff.html#6915" class="Bound">φ₀</a> <a id="6932" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6934" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a> <a id="6936" class="Symbol">→</a> <a id="6938" class="Symbol">(</a><a id="6939" href="TypeTopology.PropTychonoff.html#6939" class="Bound">φ</a> <a id="6941" class="Symbol">:</a> <a id="6943" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="6945" href="TypeTopology.PropTychonoff.html#2565" class="Bound">Y</a><a id="6946" class="Symbol">)</a> <a id="6948" class="Symbol">→</a> <a id="6950" href="TypeTopology.PropTychonoff.html#2580" class="Bound">p</a> <a id="6952" href="TypeTopology.PropTychonoff.html#6939" class="Bound">φ</a> <a id="6954" href="MLTT.Id.html#221" class="Datatype Operator">＝</a> <a id="6956" href="MLTT.Two.html#175" class="InductiveConstructor">₁</a><a id="6957" class="Symbol">)</a>
  <a id="6961" href="TypeTopology.PropTychonoff.html#6909" class="Function">γ</a> <a id="6963" class="Symbol">=</a> <a id="6965" href="TypeTopology.PropTychonoff.html#3690" class="Function">φ₀</a> <a id="6968" href="MLTT.Sigma.html#423" class="InductiveConstructor Operator">,</a> <a id="6970" href="TypeTopology.PropTychonoff.html#6784" class="Function">φ₀-is-universal-witness</a>

<a id="6995" class="Markup">\end{code}</a><a id="7005" class="Background">

And we are done.

TODO. 9 Sep 2015. We can generalize from X being a subsingleton (or
proposition) to X being subfinite (embedded into a finite type).

A particular case is the following:

</a><a id="7196" class="Markup">\begin{code}</a>

<a id="prop-tychonoff-corollary"></a><a id="7210" href="TypeTopology.PropTychonoff.html#7210" class="Function">prop-tychonoff-corollary</a> <a id="7235" class="Symbol">:</a> <a id="7237" class="Symbol">{</a><a id="7238" href="TypeTopology.PropTychonoff.html#7238" class="Bound">X</a> <a id="7240" class="Symbol">:</a> <a id="7242" href="MLTT.Universes.html#279" class="Generalizable">𝓤</a> <a id="7244" href="MLTT.Universes.html#422" class="Function Operator">̇</a> <a id="7246" class="Symbol">}</a> <a id="7248" class="Symbol">{</a><a id="7249" href="TypeTopology.PropTychonoff.html#7249" class="Bound">Y</a> <a id="7251" class="Symbol">:</a> <a id="7253" href="MLTT.Universes.html#281" class="Generalizable">𝓥</a> <a id="7255" href="MLTT.Universes.html#422" class="Function Operator">̇</a> <a id="7257" class="Symbol">}</a>
                         <a id="7284" class="Symbol">→</a> <a id="7286" href="UF.Subsingletons.html#498" class="Function">is-prop</a> <a id="7294" href="TypeTopology.PropTychonoff.html#7238" class="Bound">X</a>
                         <a id="7321" class="Symbol">→</a> <a id="7323" href="TypeTopology.CompactTypes.html#4350" class="Function">compact∙</a> <a id="7332" href="TypeTopology.PropTychonoff.html#7249" class="Bound">Y</a>
                         <a id="7359" class="Symbol">→</a> <a id="7361" href="TypeTopology.CompactTypes.html#4350" class="Function">compact∙</a> <a id="7370" class="Symbol">(</a><a id="7371" href="TypeTopology.PropTychonoff.html#7238" class="Bound">X</a> <a id="7373" class="Symbol">→</a> <a id="7375" href="TypeTopology.PropTychonoff.html#7249" class="Bound">Y</a><a id="7376" class="Symbol">)</a>
<a id="7378" href="TypeTopology.PropTychonoff.html#7210" class="Function">prop-tychonoff-corollary</a> <a id="7403" href="TypeTopology.PropTychonoff.html#7403" class="Bound">X-is-prop</a> <a id="7413" href="TypeTopology.PropTychonoff.html#7413" class="Bound">ε</a> <a id="7415" class="Symbol">=</a> <a id="7417" href="TypeTopology.PropTychonoff.html#2391" class="Function">prop-tychonoff</a> <a id="7432" href="TypeTopology.PropTychonoff.html#7403" class="Bound">X-is-prop</a> <a id="7442" class="Symbol">(λ</a> <a id="7445" href="TypeTopology.PropTychonoff.html#7445" class="Bound">x</a> <a id="7447" class="Symbol">→</a> <a id="7449" href="TypeTopology.PropTychonoff.html#7413" class="Bound">ε</a><a id="7450" class="Symbol">)</a>

<a id="7453" class="Markup">\end{code}</a><a id="7463" class="Background">

This holds even for undecided X (such as X = LPO), or when we have no
idea whether X or (X → 𝟘), and hence whether (X → Y) is 𝟙 or Y (or
none, if this is undecided)!

Better (9 Sep 2015):

</a><a id="7654" class="Markup">\begin{code}</a>

<a id="prop-tychonoff-corollary&#39;"></a><a id="7668" href="TypeTopology.PropTychonoff.html#7668" class="Function">prop-tychonoff-corollary&#39;</a> <a id="7694" class="Symbol">:</a> <a id="7696" class="Symbol">{</a><a id="7697" href="TypeTopology.PropTychonoff.html#7697" class="Bound">X</a> <a id="7699" class="Symbol">:</a> <a id="7701" href="MLTT.Universes.html#279" class="Generalizable">𝓤</a> <a id="7703" href="MLTT.Universes.html#422" class="Function Operator">̇</a> <a id="7705" class="Symbol">}</a> <a id="7707" class="Symbol">{</a><a id="7708" href="TypeTopology.PropTychonoff.html#7708" class="Bound">Y</a> <a id="7710" class="Symbol">:</a> <a id="7712" href="MLTT.Universes.html#281" class="Generalizable">𝓥</a> <a id="7714" href="MLTT.Universes.html#422" class="Function Operator">̇</a> <a id="7716" class="Symbol">}</a>
                          <a id="7744" class="Symbol">→</a> <a id="7746" href="UF.Subsingletons.html#498" class="Function">is-prop</a> <a id="7754" href="TypeTopology.PropTychonoff.html#7697" class="Bound">X</a>
                          <a id="7782" class="Symbol">→</a> <a id="7784" class="Symbol">(</a><a id="7785" href="TypeTopology.PropTychonoff.html#7697" class="Bound">X</a> <a id="7787" class="Symbol">→</a> <a id="7789" href="TypeTopology.CompactTypes.html#4350" class="Function">compact∙</a> <a id="7798" href="TypeTopology.PropTychonoff.html#7708" class="Bound">Y</a><a id="7799" class="Symbol">)</a>
                          <a id="7827" class="Symbol">→</a> <a id="7829" href="TypeTopology.CompactTypes.html#4350" class="Function">compact∙</a> <a id="7838" class="Symbol">(</a><a id="7839" href="TypeTopology.PropTychonoff.html#7697" class="Bound">X</a> <a id="7841" class="Symbol">→</a> <a id="7843" href="TypeTopology.PropTychonoff.html#7708" class="Bound">Y</a><a id="7844" class="Symbol">)</a>
<a id="7846" href="TypeTopology.PropTychonoff.html#7668" class="Function">prop-tychonoff-corollary&#39;</a> <a id="7872" class="Symbol">=</a> <a id="7874" href="TypeTopology.PropTychonoff.html#2391" class="Function">prop-tychonoff</a>

<a id="7890" class="Markup">\end{code}</a><a id="7900" class="Background">

So the function type (LPO → ℕ) is compact! (See the module LPO for a
proof.)

The Tychonoff theorem for prop-indexed products of compact types
doesn&#39;t hold. To see this, first notice that a proposition is
compact iff it is decidable. Now, the empty type 𝟘 is compact
(but not compact‌∙), and if 𝟘^P, that is, ¬P, where compact for a
proposition P, this would imply that ¬P is decidable for every
proposition P, which is weak excluded middle, which is not provable.

</a><a id="8368" class="Markup">\begin{code}</a>

<a id="8382" class="Keyword">open</a> <a id="8387" class="Keyword">import</a> <a id="8394" href="UF.ExcludedMiddle.html" class="Module">UF.ExcludedMiddle</a>

<a id="compact-prop-tychonoff-gives-WEM"></a><a id="8413" href="TypeTopology.PropTychonoff.html#8413" class="Function">compact-prop-tychonoff-gives-WEM</a> <a id="8446" class="Symbol">:</a> <a id="8448" class="Symbol">((</a><a id="8450" href="TypeTopology.PropTychonoff.html#8450" class="Bound">X</a> <a id="8452" class="Symbol">:</a> <a id="8454" href="MLTT.Universes.html#279" class="Generalizable">𝓤</a> <a id="8456" href="MLTT.Universes.html#422" class="Function Operator">̇</a> <a id="8458" class="Symbol">)</a> <a id="8460" class="Symbol">(</a><a id="8461" href="TypeTopology.PropTychonoff.html#8461" class="Bound">Y</a> <a id="8463" class="Symbol">:</a> <a id="8465" href="TypeTopology.PropTychonoff.html#8450" class="Bound">X</a> <a id="8467" class="Symbol">→</a> <a id="8469" href="MLTT.Universes.html#281" class="Generalizable">𝓥</a> <a id="8471" href="MLTT.Universes.html#422" class="Function Operator">̇</a> <a id="8473" class="Symbol">)</a>
                                       <a id="8514" class="Symbol">→</a> <a id="8516" href="UF.Subsingletons.html#498" class="Function">is-prop</a> <a id="8524" href="TypeTopology.PropTychonoff.html#8450" class="Bound">X</a>
                                       <a id="8565" class="Symbol">→</a> <a id="8567" class="Symbol">((</a><a id="8569" href="TypeTopology.PropTychonoff.html#8569" class="Bound">x</a> <a id="8571" class="Symbol">:</a> <a id="8573" href="TypeTopology.PropTychonoff.html#8450" class="Bound">X</a><a id="8574" class="Symbol">)</a> <a id="8576" class="Symbol">→</a> <a id="8578" href="TypeTopology.CompactTypes.html#3935" class="Function">compact</a> <a id="8586" class="Symbol">(</a><a id="8587" href="TypeTopology.PropTychonoff.html#8461" class="Bound">Y</a> <a id="8589" href="TypeTopology.PropTychonoff.html#8569" class="Bound">x</a><a id="8590" class="Symbol">))</a>
                                       <a id="8632" class="Symbol">→</a> <a id="8634" href="TypeTopology.CompactTypes.html#3935" class="Function">compact</a> <a id="8642" class="Symbol">(</a><a id="8643" href="MLTT.Pi.html#192" class="Function">Π</a> <a id="8645" href="TypeTopology.PropTychonoff.html#8461" class="Bound">Y</a><a id="8646" class="Symbol">))</a>
                                 <a id="8682" class="Symbol">→</a> <a id="8684" href="UF.ExcludedMiddle.html#1795" class="Function">WEM</a> <a id="8688" href="MLTT.Universes.html#279" class="Generalizable">𝓤</a>
<a id="8690" href="TypeTopology.PropTychonoff.html#8413" class="Function">compact-prop-tychonoff-gives-WEM</a> <a id="8723" class="Symbol">{</a><a id="8724" href="TypeTopology.PropTychonoff.html#8724" class="Bound">𝓤</a><a id="8725" class="Symbol">}</a> <a id="8727" class="Symbol">{</a><a id="8728" href="TypeTopology.PropTychonoff.html#8728" class="Bound">𝓥</a><a id="8729" class="Symbol">}</a> <a id="8731" href="TypeTopology.PropTychonoff.html#8731" class="Bound">τ</a> <a id="8733" href="TypeTopology.PropTychonoff.html#8733" class="Bound">X</a> <a id="8735" href="TypeTopology.PropTychonoff.html#8735" class="Bound">X-is-prop</a> <a id="8745" class="Symbol">=</a> <a id="8747" href="TypeTopology.PropTychonoff.html#8960" class="Function">δ</a> <a id="8749" href="TypeTopology.PropTychonoff.html#8882" class="Function">γ</a>
 <a id="8752" class="Keyword">where</a>
  <a id="8760" href="TypeTopology.PropTychonoff.html#8760" class="Function">Y</a> <a id="8762" class="Symbol">:</a> <a id="8764" href="TypeTopology.PropTychonoff.html#8733" class="Bound">X</a> <a id="8766" class="Symbol">→</a> <a id="8768" href="TypeTopology.PropTychonoff.html#8728" class="Bound">𝓥</a> <a id="8770" href="MLTT.Universes.html#422" class="Function Operator">̇</a>
  <a id="8774" href="TypeTopology.PropTychonoff.html#8760" class="Function">Y</a> <a id="8776" href="TypeTopology.PropTychonoff.html#8776" class="Bound">x</a> <a id="8778" class="Symbol">=</a> <a id="8780" href="MLTT.Empty-Type.html#149" class="Datatype">𝟘</a>

  <a id="8785" href="TypeTopology.PropTychonoff.html#8785" class="Function">negation-compact</a> <a id="8802" class="Symbol">:</a> <a id="8804" href="TypeTopology.CompactTypes.html#3935" class="Function">compact</a> <a id="8812" class="Symbol">(</a><a id="8813" href="TypeTopology.PropTychonoff.html#8733" class="Bound">X</a> <a id="8815" class="Symbol">→</a> <a id="8817" href="MLTT.Empty-Type.html#149" class="Datatype">𝟘</a> <a id="8819" class="Symbol">{</a><a id="8820" href="TypeTopology.PropTychonoff.html#8728" class="Bound">𝓥</a><a id="8821" class="Symbol">})</a>
  <a id="8826" href="TypeTopology.PropTychonoff.html#8785" class="Function">negation-compact</a> <a id="8843" class="Symbol">=</a> <a id="8845" href="TypeTopology.PropTychonoff.html#8731" class="Bound">τ</a> <a id="8847" href="TypeTopology.PropTychonoff.html#8733" class="Bound">X</a> <a id="8849" href="TypeTopology.PropTychonoff.html#8760" class="Function">Y</a> <a id="8851" href="TypeTopology.PropTychonoff.html#8735" class="Bound">X-is-prop</a> <a id="8861" class="Symbol">(λ</a> <a id="8864" href="TypeTopology.PropTychonoff.html#8864" class="Bound">p</a> <a id="8866" class="Symbol">→</a> <a id="8868" href="TypeTopology.CompactTypes.html#11757" class="Function">𝟘-compact</a><a id="8877" class="Symbol">)</a>

  <a id="8882" href="TypeTopology.PropTychonoff.html#8882" class="Function">γ</a> <a id="8884" class="Symbol">:</a> <a id="8886" href="MLTT.Negation.html#366" class="Function">decidable</a> <a id="8896" class="Symbol">(</a><a id="8897" href="TypeTopology.PropTychonoff.html#8733" class="Bound">X</a> <a id="8899" class="Symbol">→</a> <a id="8901" href="MLTT.Empty-Type.html#149" class="Datatype">𝟘</a> <a id="8903" class="Symbol">{</a><a id="8904" href="TypeTopology.PropTychonoff.html#8728" class="Bound">𝓥</a><a id="8905" class="Symbol">})</a>
  <a id="8910" href="TypeTopology.PropTychonoff.html#8882" class="Function">γ</a> <a id="8912" class="Symbol">=</a> <a id="8914" href="TypeTopology.CompactTypes.html#11834" class="Function">compact-decidable</a> <a id="8932" class="Symbol">(</a><a id="8933" href="TypeTopology.PropTychonoff.html#8733" class="Bound">X</a> <a id="8935" class="Symbol">→</a> <a id="8937" href="MLTT.Empty-Type.html#149" class="Datatype">𝟘</a><a id="8938" class="Symbol">)</a> <a id="8940" href="TypeTopology.PropTychonoff.html#8785" class="Function">negation-compact</a>

  <a id="8960" href="TypeTopology.PropTychonoff.html#8960" class="Function">δ</a> <a id="8962" class="Symbol">:</a> <a id="8964" href="MLTT.Negation.html#366" class="Function">decidable</a> <a id="8974" class="Symbol">(</a><a id="8975" href="TypeTopology.PropTychonoff.html#8733" class="Bound">X</a> <a id="8977" class="Symbol">→</a> <a id="8979" href="MLTT.Empty-Type.html#149" class="Datatype">𝟘</a> <a id="8981" class="Symbol">{</a><a id="8982" href="TypeTopology.PropTychonoff.html#8728" class="Bound">𝓥</a><a id="8983" class="Symbol">})</a> <a id="8986" class="Symbol">→</a> <a id="8988" href="MLTT.Negation.html#366" class="Function">decidable</a> <a id="8998" class="Symbol">(</a><a id="8999" href="MLTT.Negation.html#333" class="Function Operator">¬</a> <a id="9001" href="TypeTopology.PropTychonoff.html#8733" class="Bound">X</a><a id="9002" class="Symbol">)</a>
  <a id="9006" href="TypeTopology.PropTychonoff.html#8960" class="Function">δ</a> <a id="9008" class="Symbol">(</a><a id="9009" href="MLTT.Plus-Type.html#198" class="InductiveConstructor">inl</a> <a id="9013" href="TypeTopology.PropTychonoff.html#9013" class="Bound">f</a><a id="9014" class="Symbol">)</a> <a id="9016" class="Symbol">=</a> <a id="9018" href="MLTT.Plus-Type.html#198" class="InductiveConstructor">inl</a> <a id="9022" class="Symbol">(</a><a id="9023" href="MLTT.Empty.html#384" class="Function">𝟘-elim</a> <a id="9030" href="MLTT.Pi.html#541" class="Function Operator">∘</a> <a id="9032" href="TypeTopology.PropTychonoff.html#9013" class="Bound">f</a><a id="9033" class="Symbol">)</a>
  <a id="9037" href="TypeTopology.PropTychonoff.html#8960" class="Function">δ</a> <a id="9039" class="Symbol">(</a><a id="9040" href="MLTT.Plus-Type.html#215" class="InductiveConstructor">inr</a> <a id="9044" href="TypeTopology.PropTychonoff.html#9044" class="Bound">ϕ</a><a id="9045" class="Symbol">)</a> <a id="9047" class="Symbol">=</a> <a id="9049" href="MLTT.Plus-Type.html#215" class="InductiveConstructor">inr</a> <a id="9053" class="Symbol">(</a><a id="9054" href="MLTT.Negation.html#988" class="Function">contrapositive</a> <a id="9069" class="Symbol">(λ</a> <a id="9072" href="TypeTopology.PropTychonoff.html#9072" class="Bound">f</a> <a id="9074" class="Symbol">→</a> <a id="9076" href="MLTT.Empty.html#384" class="Function">𝟘-elim</a> <a id="9083" href="MLTT.Pi.html#541" class="Function Operator">∘</a> <a id="9085" href="TypeTopology.PropTychonoff.html#9072" class="Bound">f</a><a id="9086" class="Symbol">)</a> <a id="9088" href="TypeTopology.PropTychonoff.html#9044" class="Bound">ϕ</a><a id="9089" class="Symbol">)</a>

<a id="9092" class="Markup">\end{code}</a><a id="9102" class="Background">
</a></pre></body></html>